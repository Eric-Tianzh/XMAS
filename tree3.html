<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Proton Tree with Spiral Ribbon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        #info { 
            position: absolute; top: 15px; width: 100%; text-align: center; 
            color: #ffffff; font-family: 'Segoe UI', sans-serif; pointer-events: none; 
            z-index: 100; text-shadow: 0 0 10px #2ecc71;
        }
    </style>
</head>
<body>
    <div id="info">PROTON TREE: SPIRAL ENERGY<br><small style="opacity:0.6">SWIPE TO ROTATE</small></div>
    
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, treeGroup, starPoints, ribbonPoints;
        let rotY = 0, rotX = 0.2;
        let isDown = false, px, py;

        // 生成发光贴图 (通用)
        function createPTexture(colorStr) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.3, colorStr);
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        // 绘制五角星形状
        function createStarShape() {
            const shape = new THREE.Shape();
            const pts = 5;
            const outerRadius = 6;
            const innerRadius = 3;
            for (let i = 0; i < pts * 2; i++) {
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                const a = (i / pts) * Math.PI - Math.PI/2;
                if (i === 0) shape.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                else shape.lineTo(Math.cos(a) * r, Math.sin(a) * r);
            }
            return shape;
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
            camera.position.z = 220;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            // 1. 背景星空
            const sGeo = new THREE.BufferGeometry();
            const sPos = [];
            for(let i=0; i<3000; i++) sPos.push((Math.random()-0.5)*1500, (Math.random()-0.5)*1500, (Math.random()-0.5)*1500);
            sGeo.setAttribute('position', new THREE.Float32BufferAttribute(sPos, 3));
            starPoints = new THREE.Points(sGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.8}));
            scene.add(starPoints);

            // 2. 基础绿色质子树
            const tGeo = new THREE.BufferGeometry();
            const tPos = [], tCol = [];
            for(let i=0; i<3500; i++) {
                const y = Math.random() * 140 - 70;
                const r = ((70 - y) / 140) * 60 + 1;
                const a = Math.random() * Math.PI * 2;
                tPos.push(Math.cos(a)*r, y, Math.sin(a)*r);
                const c = new THREE.Color();
                c.setHSL(0.35, 0.9, 0.3 + Math.random()*0.3);
                tCol.push(c.r, c.g, c.b);
            }
            tGeo.setAttribute('position', new THREE.Float32BufferAttribute(tPos, 3));
            tGeo.setAttribute('color', new THREE.Float32BufferAttribute(tCol, 3));
            const treeMat = new THREE.PointsMaterial({
                size: 3.5, map: createPTexture('rgba(46,204,113,0.8)'), transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, vertexColors: true
            });
            treePoints = new THREE.Points(tGeo, treeMat);
            treeGroup.add(treePoints);

            // 3. 白色螺旋粒子环绕带 (向上盘旋约3圈)
            const rGeo = new THREE.BufferGeometry();
            const rPos = [];
            const ribbonCount = 800;
            for(let i=0; i<ribbonCount; i++) {
                // 这里的 i/ribbonCount 决定了粒子在螺旋线上的位置
                const t = i / ribbonCount; 
                const y = t * 140 - 70; // 从下往上
                const angle = t * Math.PI * 2 * 3.5; // 3.5 圈
                const r = ((70 - y) / 140) * 62 + 2; // 比树身稍微宽一点点
                rPos.push(Math.cos(angle)*r, y, Math.sin(angle)*r);
            }
            rGeo.setAttribute('position', new THREE.Float32BufferAttribute(rPos, 3));
            const ribbonMat = new THREE.PointsMaterial({
                size: 5, map: createPTexture('rgba(255,255,255,0.9)'), transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, color: 0xffffff
            });
            ribbonPoints = new THREE.Points(rGeo, ribbonMat);
            treeGroup.add(ribbonPoints);

            // 4. 实心五角星顶星
            const starShape = createStarShape();
            const starGeo = new THREE.ShapeGeometry(starShape);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide });
            const starMesh = new THREE.Mesh(starGeo, starMat);
            starMesh.position.y = 75;
            treeGroup.add(starMesh);

            // 交互逻辑
            const down = (x,y) => { isDown = true; px = x; py = y; };
            const move = (x,y) => {
                if(!isDown) return;
                rotY += (x - px) * 0.01;
                rotX += (y - py) * 0.01;
                px = x; py = y;
            };
            window.addEventListener('mousedown', e => down(e.clientX, e.clientY));
            window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
            window.addEventListener('mouseup', () => isDown = false);
            window.addEventListener('touchstart', e => down(e.touches[0].clientX, e.touches[0].clientY));
            window.addEventListener('touchmove', e => move(e.touches[0].clientX, e.touches[0].clientY));
            window.addEventListener('touchend', () => isDown = false);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // 1. 整体自动旋转
            rotY += 0.005; 
            treeGroup.rotation.y = rotY;
            treeGroup.rotation.x = rotX;
            
            // 2. 星空背景极慢旋转
            starPoints.rotation.y += 0.0003;

            // 3. 螺旋带动力学：让白色粒子产生向上流动的错觉
            // 通过微调位置实现
            const positions = ribbonPoints.geometry.attributes.position.array;
            for(let i=0; i<positions.length; i+=3) {
                // 获取当前粒子的 Y 坐标并向上微移
                positions[i+1] += 0.4;
                // 如果超过顶部，回到旋转轴底部
                if(positions[i+1] > 70) {
                    positions[i+1] = -70;
                }
                // 根据新的 Y 重新计算 X 和 Z 保持螺旋形状
                const t = (positions[i+1] + 70) / 140;
                const angle = t * Math.PI * 2 * 3.5;
                const r = ((70 - positions[i+1]) / 140) * 62 + 2;
                positions[i] = Math.cos(angle) * r;
                positions[i+2] = Math.sin(angle) * r;
            }
            ribbonPoints.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>